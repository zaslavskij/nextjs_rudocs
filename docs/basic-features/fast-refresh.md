---
description: 

Быстрое обновление в Next.js - это мгновенная обратная связь,
которая показывает вам изменения, внесенные в ваши React-компоненты.

---

# Быстрое обновление

<details open>
  <summary><b>Примеры</b></summary>
  <ul>
    <li><a href="https://github.com/vercel/next.js/tree/canary/examples/fast-refresh-demo">Fast Refresh Demo</a></li>
  </ul>
</details>

Быстрое обновление - это функция Next.js, которая дает мгновенную обратную связь на изменения,
внесенные в ваши компоненты. Быстрое обновление доступно из коробки для всех версий Next.js,
начиная с **9.4 и позднее**. С помощью быстрого обновления большинство изменений становятся
видимыми в течении секунды, **без потери состояния компонента**.

## Как это работает

- Если вы вносите измениния в файл, который содержит **только экспорт React-компонента (компонентов)**,
  быстрое обновление обновит код только для этого файла и перерендерит ваш компонент. Вы можете изменять
  в этом файле все что угодно - стили, логику рендеринга, обработчики событий или эффекты.
- Если вы вносите изменения в файл, который **не экспортирует React-компоненты**, быстрое обновление
  перезапустит процессинг этого файла и всех других файлов, которые его импортируют. Так, если в
  `Button.js` и `Modal.js` импортируется файл `theme.js`, то изменения в файле `theme.js` запустят обновление
  обоих компонентов, в которые он импортирован.
- Наконец, если вы **редактируете файл**, код которого **импортируется вне дерева React**,
  быстрое обновление **осуществит полную перезагрузку проекта**. У вас может быть файл, который
  рендерит React-компонент, но вместе с этим экспортирует какое-либо значение, которое используется
  в коде, который **не относится к React-компонентам**. Например, файл компонента экспортирует константу,
  которая импортируется в не связанную с React утилиту. В этом случае хорошей практикой будет вынесение константы
  в отдельный файл с последующим импортом туда, где она необходима. Такой подход исправит работу быстрого
  обновления на уровне компонента. Все подобные случаи решаются аналогично.

## Устойчивость к ошибкам

### Синтаксические ошибки

Если вы совершаете синтаксические ошибки во время разработки, вы можете исправить их и сохранить
файл снова. Ошибка исчезнет автоматически и вам не нужно перезагружать
приложение. **Вы не должны потерять состояние компонента**.

### Ошибки в рантайме (во время выполнения)

Если вы совершили ошибку, которая возникает при выполнении кода, вы увидите соответсвующее
сообщение (оверлей) о ней в браузере, на текущей станице. Исправление ошибки автоматически
скроет сообщение о ней, без перезагрузки приложения.

Если ошибка возникла не во время рендеринга, то состояние компонента будет сохранено. Если ошибка
возникла во время рендеринга, React перемонтирует преложение с использованием обновленного кода.

Если вы в приложении используете [предохранители (компоненты Error Boundary)](https://reactjs.org/docs/error-boundaries.html)
(которые являются хорошим решением для изящной деградации на продакшне), они будут повторять
рендеринг при последующем редактировании кода после ошибки. Это означает, что наличие предохранителей
может уберечь вас от постоянного сброса состояния приложения на дефолтное. Однако стоит использовать
предохранители с умом и не злоупотреблять ими, тк они используются в продакшне.

## Ограничения

Механизм быстрого обновления постарается сохранить локальное состояние компонента, но
только в том случае, если это безопасно. Вот несколько возможных причин, по которым
локальное состояние может сбрасываться при каждом изменении в файле:

- Локальное состояние не может сохраняться в классовых компонентах (только функциональные
  компоненты и хуки сохраныяют состояние).
- Файл с компонентом помимо самого компонента экспортирует что-то еще.
- Иногда из файла экспортируется результат вызова компонента высшего порядка (`higher-order component - HOC`),
  например, `HOC(WrappedComponent)`. Если результатом вызова окажется класс, то состояние будет сброшено.
- Анонимные стрелочные функции вроде `export default () => <div />;` могут также послужить причиной
  быстрого обновления без сохранения состояния. Для больших объемов кода вы можете прибегать к использованию
  нашего [`name-default-component`](/docs/advanced-features/codemods.md#name-default-component).

По мере того как ваша кодовая база будет переписана на функциональные
компоненты с использованием Hooks, вы можете рассчитывать на сохранение состояния в большем количестве случаев.

## Подсказки

- Быстрое обновление по умолчанию сохраняет локальное состояние в функциональных компонентах и хуках (Hooks).
- Иногда вам моджет понадобиться _принудительно_ сбросить состояние и перемонтировать компонент.
  Например, это может быть полезно, когда вы настраиваете анимацию, которая воспроизводится
  только тогда, когда компонент монтируется. Для этого нужно добавить `// @refresh reset` в любое место редактируемого
  файла. Эта директива работает на уровне файла и сообщает механизму быстрого обновления о том, что компоненты,
  определенные в этом файле, необходимо перемонтировать на каждое изменение в нем.
- В процессе разработки вы можете добавить в `console.log` или `debugger;` в компоненты над которыми вы работаете.

## Быстрое обновление и хуки (Hooks)

Когда это возможно, быстрое обновление сохраняет состояние компонента между изменениями.
В частности, хуки `useState` и `useRef` сохраняют свои значения до тех пор, пока
вы не измените их аргументы или порядок вызова данных хуков.

Хуки со списками зависимостей, такие как `useEffect`, `useMemo`, и `useCallback` будут обновляться
_всегда_ во время быстрого обновления. Их список зависимостей будет проигнорирован пока происходит
быстрое обновление.

Например, если вы изменили хук `useMemo(() => x * 2, [x])`, сделав его таким `useMemo(() => x * 10, [x])` -
это приведет к перезапуску, не смотря на то, что значение переменной `x` из списка зависмостей не было изменено.
Если бы React этого не сделал, то ваши изменения попросту бы не отобразились на экране!

Иногда это может привести к неожиданным результатам. Например, даже если `useEffect` имеет пустой
массив зависимостей,он будет запускаться каждый раз во время быстрого обновления.

Однако написание кода, устойчивого к случайному перезапуску `useEffect` считается хорошей практикой,
вне зависимости от наличия Fast Refresh. Для упрощения работы со списком зависимостей мы рукомендем вам
включить [React Strict Mode](/docs/api-reference/next.config.js/react-strict-mode.md).
