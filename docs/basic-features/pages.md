---
description: В Next.js страницы являются React-компонентами, который экспортируется из файла, расположенного в директории `pages`. Узнайте как это работает.
---

# Страницы

> Этот документ предназначен для Next.js версий 9.3 и выше. Если вы пользуетесь более старыми версиями, обратитесь к [предыдущей документации](https://nextjs.org/docs/tag/v9.2.2/basic-features/pages).

В Next.js **страница является** [React-компонентом](https://reactjs.org/docs/components-and-props.html), который может быть экспортирован из директории `pages` и иметь одно из следующих расширений: `.js`, `.jsx`, `.ts` или `.tsx`. Каждая страница связана с маршрутом, который соответствует названию файла из которого она экспортируется.

**Пример**: Если вы создадите страницу `pages/about.js`, которая будет экспортировать компонент приведенный ниже, то страница будет доступна по маршруту `/about`.

```jsx
function About() {
	return <div>About</div>;
}

export default About;
```

### Страницы с динамическими маршрутами

Next.js поддерживает динамическую маршрутизацию. Так, если вы создаете файл с именем `pages/posts/[id].js`, он станет доступен по маршрутам `posts/1`, `posts/2`, и т.д.

> Для того, чтобы узнать больше о динамических маршрутах, обратитесь к [документации по динамическим маршрутам](/docs/routing/dynamic-routes.md).

## Пре-рендеринг

Next.js по умолчанию **пре-рендерит** каждую страницу. Это значит, что Next.js генерирует HTML для каждой страницы заранее, вместо того чтобы делать это с помощью клиентского JavaScript. Пре-рендеринг может хорошо сказаться
на скорости работы и SEO.

Каждая сгенерированная HTML-страница связана с минимальным количеством JavaScript-кода, необходимого для этой страницы. Когда страница загружена браузером, этот JavaScript делает е полностью интерактивной. (Данный процесс называется _гидрацией (hydration)_.

### Два вида пре-рендеринга

В Next.js существует два вида пре-рендеринга: **Статическая генерация (Static Site Generation - SSG)** and **Серверный рендеринг (Server-side Rendering - SSR)**. Разница состоит в том, **в какой момент** будет сгенерирована страница.

- [**SSG (рекомендуется)**](#static-generation-recommended): HTML страница создается в **момент сборки** и переиспользуется на каждый запрос.
- [**SSR**](#server-side-rendering): HTML страница создается заново **на каждый пользовательский запрос**.

Next.js предоставляет вам возможность **выбора**, какой режим рендеринга использовать для какой страницы. Вы можете создать "гибридное" приложение на Next.js, используя статическую генерацию для большинства страниц и серверный рендеринг для всех остальных.

По причинам производительности мы **рекомендуем** использовать **статическую генерацию** вместо серверного рендеринга везде, где это возможно. Статически сгенерированные страницы могут быт кешированы с помощью CDN без каких-либо дополнительных действий. Тем не менее, серверный рендеринг в ряде случаев является единственным возможным решением задачи.

Вы можете использовать также и **рендеринг на стороне клиента (Client-side Rendering - CSR)** вместе с серверным рендерингом или статической генерацией.
Это значит, что некоторые части страницы могут быть отрендерены с помощью клиентского JavaScript. Чтобы узнать больше, обратитесь к документации по [Получению данных](/docs/basic-features/data-fetching.md#fetching-data-on-the-client-side).

## Статическая генерация (рекомендуется)

<details open>
  <summary><b>Примеры</b></summary>
  <ul>
    <li><a href="https://github.com/vercel/next.js/tree/canary/examples/cms-wordpress">WordPress</a> (<a href="https://next-blog-wordpress.vercel.app">Demo</a>)</li>
    <li><a href="https://github.com/vercel/next.js/tree/canary/examples/blog-starter">Блог с использованием markdown-файлов</a> (<a href="https://next-blog-starter.vercel.app/">Demo</a>)</li>
    <li><a href="https://github.com/vercel/next.js/tree/canary/examples/cms-datocms">DatoCMS</a> (<a href="https://next-blog-datocms.vercel.app/">Demo</a>)</li>
    <li><a href="https://github.com/vercel/next.js/tree/canary/examples/cms-takeshape">TakeShape</a> (<a href="https://next-blog-takeshape.vercel.app/">Demo</a>)</li>
    <li><a href="https://github.com/vercel/next.js/tree/canary/examples/cms-sanity">Sanity</a> (<a href="https://next-blog-sanity.vercel.app/">Demo</a>)</li>
    <li><a href="https://github.com/vercel/next.js/tree/canary/examples/cms-prismic">Prismic</a> (<a href="https://next-blog-prismic.vercel.app/">Demo</a>)</li>
    <li><a href="https://github.com/vercel/next.js/tree/canary/examples/cms-contentful">Contentful</a> (<a href="https://next-blog-contentful.vercel.app/">Demo</a>)</li>
    <li><a href="https://github.com/vercel/next.js/tree/canary/examples/cms-strapi">Strapi</a> (<a href="https://next-blog-strapi.vercel.app/">Demo</a>)</li>
    <li><a href="https://github.com/vercel/next.js/tree/canary/examples/cms-prepr">Prepr</a> (<a href="https://next-blog-prepr.vercel.app/">Demo</a>)</li> 
    <li><a href="https://github.com/vercel/next.js/tree/canary/examples/cms-agilitycms">Agility CMS</a> (<a href="https://next-blog-agilitycms.vercel.app/">Demo</a>)</li>
    <li><a href="https://github.com/vercel/next.js/tree/canary/examples/cms-cosmic">Cosmic</a> (<a href="https://next-blog-cosmic.vercel.app/">Demo</a>)</li>
    <li><a href="https://github.com/vercel/next.js/tree/canary/examples/cms-buttercms">ButterCMS</a> (<a href="https://next-blog-buttercms.vercel.app/">Demo</a>)</li>
    <li><a href="https://github.com/vercel/next.js/tree/canary/examples/cms-storyblok">Storyblok</a> (<a href="https://next-blog-storyblok.vercel.app/">Demo</a>)</li>
    <li><a href="https://github.com/vercel/next.js/tree/canary/examples/cms-graphcms">GraphCMS</a> (<a href="https://next-blog-graphcms.vercel.app/">Demo</a>)</li>
    <li><a href="https://github.com/vercel/next.js/tree/canary/examples/cms-kontent">Kontent</a> (<a href="https://next-blog-kontent.vercel.app/">Demo</a>)</li>
    <li><a href="https://static-tweet.vercel.app/">Static Tweet Demo</a></li>
  </ul>
</details>

Если страница использует **статическую генерацию**, то HTML для нее будет сгенерирован **во время сборки**. Это означает, что для продакшна HTML для страницы генерируется запуском команды `next build` . Этот HTML будет переиспользован на каждый запрос и может быть кеширован с помощью CDN.

В Next.js вы можете сгенерировать страницы **с данными или без них**. Давайте рассмотрим каждый случай.

### Статическая генерация без данных

Next.js по умолчанию пре-рендерит страницы используя статическую генерацию без получения данных. Пример:

```jsx
function About() {
	return <div>About</div>;
}

export default About;
```

Обратите внимание, что страница выше не нуждается во внешних данных, чтобы быть отрендеренной. В подобных случаях Next.js во время сборки генерирует отдельный HTML файл для каждой такой страницы.

### Статическая генерация с данными

Некоторые страницы требует получения внешних данных для того, чтобы их отрендерить. Существует два сценария, любой из которых или даже оба сразу могут быть применены.
В каждом случае вы можете использовать специальную функцию, которая имеется в Next.js:

1. **Содержимое** вашей страницы зависит от внешних данных: следует использовать `getStaticProps`.
2. **Маршруты** вашей страницы зависят от внешних данных: следует использовать `getStaticPaths` (обычно в дополнении к `getStaticProps`).

#### Вариант 1: **Содержимое** вашей страницы зависит от внешних данных

**Пример**: Для страницы блога необходим список записей из CMS (системы по управлению контентом).

```jsx
// TODO: нужно получить `posts` (вызовом какого-либо API)
//       до того, как для страницы будет сделан пре-рендер.
function Blog({ posts }) {
	return (
		<ul>
			{posts.map((post) => (
				<li>{post.title}</li>
			))}
		</ul>
	);
}

export default Blog;
```

Чтобы получить эти данные для пре-рендеринга, Next.js дает возможность экспортировать (`export`) асинхронную (`async`) функцию с названием `getStaticProps`. Экспорт функции нужно делать из файла страницы, для которой необходимы данные. Эта функция вызывается во время сборки и дает вам возможность передать полученные данные в `props` страницы для ее пре-рендера.

```jsx
function Blog({ posts }) {
	// Рендер записей...
}

// Эта функция вызывается во время сборки
export async function getStaticProps() {
	// API-вызов для получения записей
	const res = await fetch("https://.../posts");
	const posts = await res.json();

	// Значение, которое возвращается в { props: { posts } }, будет получено
	// компонентом страницы Blog во время сборки
	return {
		props: {
			posts,
		},
	};
}

export default Blog;
```

Чтобы узнать больше о том, как работает функция `getStaticProps`, ознакомьтес с [документацией по получению данных](/docs/basic-features/data-fetching.md#getstaticprops-static-generation).

#### Вариант 2: маршруты до вашей страницы зависят от внешних данных

Next.js позволяет вам создавать стораницы с **динамической маршрутизацией**. Например, вы можете создать файл `pages/posts/[id].js` для отображения отдельной записи блога, где `id` - это идентификатор записи. Это позволит
вам показать запись блога с `id: 1`, когда будет совершен запрос по маршруту `posts/1`.

> Чтобы узнать больше о динамической маршрутизации, обратитесь к [документации по динамической маршрутизации](/docs/routing/dynamic-routes.md).

Тем не мение, вам необходимы внешние данные для того, чтобы определить какие посты (`id`) вам необходимо пререндерить во время сборки.

**Пример**: предположим, что вы только что добавили одну запись (пост в блог с `id: 1`) в базу данных. В этом случае вам нужно предварительно отрендерить только страницу по маршруту `posts/1`.

Позднее вы можете добавить вторую запись в блог с `id: 2`. Так, вам понадобится еще сделать пре-рендер для `posts/2`.

Так, **маршруты** для страниц, которые вы пре-рендерите зависят от **внешних данных**. Чтобы построить эти маршруты, Next.js позволяет вам экспортировать (`export`) асинхронную (`async`) функцию с именем `getStaticPaths` для вашей динамической страницы (в данном случае - `pages/posts/[id].js`). Эта функция вызывается во время сборки и позволяет вам определить для каких маршрутов нужен пре-рендер.

```jsx
// Эта функция вызывается во время сборки
export async function getStaticPaths() {
	// API-вызов для получения записей
	const res = await fetch("https://.../posts");
	const posts = await res.json();

	// На основе записей получаем маршруты,
	// для которых нужно сделать пре-рендер
	const paths = posts.map((post) => ({
		params: { id: post.id },
	}));

	// Мы сделаем пре-рендер только для этих маршрутов.
	// { fallback: false } - означает, что для остальных подобных маршрутов будет 404.
	return { paths, fallback: false };
}
```

Также для страницы `pages/posts/[id].js` вам понадобится экспортировать функцию `getStaticProps`,
чтобы получить данные записи с соответсвующим `id` и использовать их для пре-рендера:

```jsx
function Post({ post }) {
	// Рендер записи...
}

export async function getStaticPaths() {
	// ...
}

// Тоже вызывается во время сборки
export async function getStaticProps({ params }) {
	// params содержат `id` поста.
	// Так, если маршрут выглядит так `/posts/1`, то params.id = 1
	const res = await fetch(`https://.../posts/${params.id}`);
	const post = await res.json();

	// Передача данных записи в компонент страницы, с помозью props
	return { props: { post } };
}

export default Post;
```

Чтобы больше узнать о том, как работает функция `getStaticPaths`, ознакомьтесь с [документацией по получению данных](/docs/basic-features/data-fetching.md#getstaticpaths-static-generation).

### Когда я должен использовать статическую генерацию (Static Site Generation)?

Мы рекомендуем использовать **статическую генерацию** (с данными и без) всегда где это возможно,
потому что ваша страница будет отрендерена один раз и отдаваться с помощью CDN, что позволяет
отображать ее значительно быстрее, по сравнению с серверным рендерингом на каждый запрос страницы.

Вы можете использовать статическую генерацию для множества типов страниц, включая:

- Маркетинговые страницы
- Записи блога
- Страницы e-commerce со списками продуктов
- Страницы помощи и документации

Вы должны задаваться вопросом: "могу ли я пре-рендерить страницу **до запроса** пользователя?" И если ответ утвердительный, вам следует использовать статическую генерацию.

С другой стороны, статическая генерация не подходит для страниц, которые вы не можете отрендерить до пользовательского запроса.
Например, когда ваша страница отображает часто обновляемые данные и ее содержимое меняется на каждый запрос.

В подобных случаях вы можете прибегнуть к одной из рекомендаций из списка ниже:

- Использовать статическую генерацию вместе с **рендерингом на стороне клиента:** вы можете не использовать пре-рендеринг для некоторых частей вашей страницы и затем наполнить их данными на стороне клиента. Чтобы узнать больше об этом подходе, обратитесь к [документации по получению данных](/docs/basic-features/data-fetching.md#fetching-data-on-the-client-side).
- Использовать **рендеринг на стороне сервера:** Next.js будет пре-рендерить страницу на каждый запрос. Это будет медленее, потому как такую страницу не сможет кешировать CDN, но эти страницы будут всегда актуальными. Поговорим об этом подходе ниже.

## Рендеринг на стороне сервера

> Обычно его называют "SSR" (от "Server-side rendering") или "динамический рендеринг".

Если страница использует **рендеринг на стороне сервера**, то HTML для нее генерируется на **каждый запрос**.

Для того, чтобы использоваеть серверный рендеринг на странице, экспортируйте (`export`) асинхронную (`async`)
функцию с именем `getServerSideProps`. Эта функция будет вызываться сервером на каждый запрос.

Предположим, что ваша страница должна отображать часто обновляемые данные (получаемые из внешнего API). Вы можете использовать функцию `getServerSideProps`,
которая получит данные и передаст их `Page`, как это показано ниже:

```jsx
function Page({ data }) {
	// Рендеринг данных...
}

// Вызывается на каждый запрос
export async function getServerSideProps() {
	// API-вызов для получения записей
	const res = await fetch(`https://.../data`);
	const data = await res.json();

	// Передача данных компоненту страницы через props
	return { props: { data } };
}

export default Page;
```

Как вы могли заметить, функция `getServerSideProps` аналогична `getStaticProps`, но с той разницей, что `getServerSideProps` вызывается на каждый запрос.

Чтобы узнать больше о том, как работает функция `getServerSideProps`, обратитесь к [документации по получению данных](/docs/basic-features/data-fetching.md#getserversideprops-server-side-rendering)

## Резюме

Мы обсудили два вида пре-рендеринга страниц:

- **Статическая генерация (предпочтительно):** HTML генерируется **во время собрки** и будет переиспользован на каждый запрос. Для того, чтобы создать страницу со статической генерацией, необходимо экспортировать помимо компонента страницы функцию `getStaticProps` (и `getStaticPaths`, если это необходимо). Этот вариант отлично подходит для страниц, которые могут быть отрендерены до пользовательского запроса. Вы также можете использовать и
  рендеринг на стороне клиента, чтобы дополнительно отобразить необходимые данные.
- **Серверный рендеринг:** HTML генерируется **на каждый запрос**. Чтобы создать страницу, которая рендерится на сервере, экспортируйте функцию `getServerSideProps`. Поскольку серверный рендерингв сравнении со статической генерацией менее производителен, используйте его только там, где он действительно необходим.

## Узнать больше

Дальше мы рекомендуем вам прочесть слндующие разделы:

<div class="card">
  <a href="/docs/basic-features/data-fetching.md">
    <b>Получение данных:</b>
    <small>Узнайте больше о получении данных в Next.js.</small>
  </a>
</div>

<div class="card">
  <a href="/docs/advanced-features/preview-mode.md">
    <b>Режим превью:</b>
    <small>Узнайте больше о режиме превью в Next.js.</small>
  </a>
</div>

<div class="card">
  <a href="/docs/routing/introduction.md">
    <b>Маршрутизация:</b>
    <small>Узнайте больше о маршрутизации в Next.js.</small>
  </a>
</div>

<div class="card">
  <a href="/docs/basic-features/typescript.md#pages">
    <b>TypeScript:</b>
    <small>Добавьте к своим страницам TypeScript.</small>
  </a>
</div>
